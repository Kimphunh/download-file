name: Download File and Release

on:
  workflow_dispatch:
    inputs:
      file_url:
        description: 'URL of the file to download'
        required: true
        default: ''
      file_name_replace:
        description: 'Replacement name for the downloaded file (leave blank to use original filename from URL)'
        required: false
        default: ''

jobs:
  identify_file_name:
    runs-on: ubuntu-latest
    outputs:
      file_name: ${{ steps.determine_file_info.outputs.file_name }}

    steps:
      - name: Determine file name
        id: determine_file_info
        run: |
          FILE_URL="${{ github.event.inputs.file_url }}"
          FILE_NAME=$(basename "${FILE_URL}")
          FILE_EXTENSION="${FILE_NAME##*.}"
          if [ -z "${FILE_NAME}" ]; then
            FILE_NAME="temp.file"
            echo "::warning::Unable to identify file name"
          fi
          echo "::set-output name=file_name::${FILE_NAME}"

  download_file:
    needs: identify_file_name
    runs-on: ubuntu-latest

    steps:
      - name: Download file
        run: wget "${{ github.event.inputs.file_url }}" -O "${{ needs.identify_file_name.outputs.file_name }}"

  edit_final:
    needs: download_file
    runs-on: ubuntu-latest

    steps:
      - name: Determine new file name
        id: determine_new_file_name
        run: |
          REPLACE_NAME="${{ github.event.inputs.file_name_replace }}"
          if [ -n "${REPLACE_NAME}" ]; then
            NEW_FILE_NAME="${REPLACE_NAME}"
            FILE_EXTENSION="${REPLACE_NAME##*.}"
            if [ -z "${FILE_EXTENSION}" ]; then
              FILE_EXTENSION="${{ needs.identify_file_name.outputs.file_name }}"
              NEW_FILE_NAME="${NEW_FILE_NAME}.${FILE_EXTENSION}"
            fi
          else
            NEW_FILE_NAME="${{ needs.identify_file_name.outputs.file_name }}"
          fi
          echo "::set-output name=new_file_name::${NEW_FILE_NAME}"

      - name: Determine new release version
        id: determine_release_version
        run: |
          LAST_RELEASE_TAG=$(git describe --abbrev=0 --tags)
          LAST_VERSION=${LAST_RELEASE_TAG#v*}
          IFS='.' read -r major minor patch <<< "$LAST_VERSION"
          NEW_PATCH=$((patch + 1))
          NEW_VERSION="v${major}.${minor}.${NEW_PATCH}"
          echo "::set-output name=new_release_version::${NEW_VERSION}"

      - name: Create release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.determine_release_version.outputs.new_release_version }}
          release_name: Release ${{ needs.determine_release_version.outputs.new_release_version }}
          body: |
            File URL: ${{ github.event.inputs.file_url }}
          draft: false
          prerelease: false

      - name: Upload release asset
        id: upload-release-asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ${{ github.workspace }}/${{ needs.identify_file_name.outputs.file_name }}
          asset_name: ${{ needs.edit_final.outputs.new_file_name }}
          asset_content_type: application/octet-stream
